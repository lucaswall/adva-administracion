/**
 * Webhook routes for external notifications
 */

import type { FastifyInstance } from 'fastify';
import {
  getActiveChannels,
  isNotificationDuplicate,
  markNotificationProcessed,
  triggerScan,
} from '../services/watch-manager.js';
import { createRateLimiter } from '../utils/rate-limiter.js';

/**
 * Drive push notification headers
 */
interface DriveNotificationHeaders {
  'x-goog-channel-id'?: string;
  'x-goog-resource-id'?: string;
  'x-goog-resource-state'?: string;
  'x-goog-changed'?: string;
  'x-goog-message-number'?: string;
}

/**
 * Register webhook routes
 */
export async function webhookRoutes(server: FastifyInstance) {
  // Create rate limiter: 60 requests per minute per channelId
  const rateLimiter = createRateLimiter(60000, 60);

  /**
   * POST /webhooks/drive - Handle Drive push notifications
   * Public endpoint (no authentication required)
   *
   * Google Drive sends notifications when files change in a watched folder.
   * This endpoint receives those notifications and triggers processing.
   *
   * Security: Google Drive push notifications cannot send custom auth headers.
   * Instead, this endpoint validates:
   * - Channel IDs (UUIDs generated by our server, unknown to external parties)
   * - Resource IDs (ensures notifications are for expected resources)
   * - Duplicate detection (prevents replay attacks)
   *
   * Headers include:
   * - X-Goog-Channel-ID: Our channel ID
   * - X-Goog-Resource-ID: Resource being watched
   * - X-Goog-Resource-State: 'sync', 'add', 'update', 'remove', 'trash', 'untrash', 'change'
   * - X-Goog-Changed: Comma-separated list (only with 'update'): 'content', 'properties', 'parents', 'children', 'permissions'
   * - X-Goog-Message-Number: Sequence number
   *
   * See: https://developers.google.com/workspace/drive/api/guides/push
   */
  server.post('/drive', async (request, reply) => {
    const headers = request.headers as DriveNotificationHeaders;

    const channelId = headers['x-goog-channel-id'];
    const resourceId = headers['x-goog-resource-id'];
    const resourceState = headers['x-goog-resource-state'];
    const changed = headers['x-goog-changed'];
    const messageNumber = headers['x-goog-message-number'];

    server.log.info({
      channelId,
      resourceId,
      resourceState,
      changed,
      messageNumber
    }, 'Drive notification received');

    // Validate channel ID is present
    if (!channelId) {
      server.log.warn('Received notification without channel ID');
      return reply.code(200).send({ status: 'ignored', reason: 'missing_channel_id' });
    }

    // Validate channel ID matches an active channel
    const activeChannels = getActiveChannels();
    const channel = activeChannels.find(c => c.channelId === channelId);
    if (!channel) {
      server.log.warn({ channelId }, 'Received notification for unknown channel');
      return reply.code(200).send({ status: 'ignored', reason: 'unknown_channel' });
    }

    // Validate resource ID matches the channel's resource ID
    if (!resourceId || resourceId !== channel.resourceId) {
      server.log.warn({
        channelId,
        expected: channel.resourceId,
        received: resourceId
      }, 'Resource ID mismatch');
      return reply.code(200).send({ status: 'ignored', reason: 'resource_mismatch' });
    }

    // Check rate limit for this channel (after validation to prevent DoS)
    const rateLimitResult = rateLimiter.check(channelId);
    if (!rateLimitResult.allowed) {
      server.log.warn({
        channelId,
        resetMs: rateLimitResult.resetMs
      }, 'Rate limit exceeded for channel');
      return reply
        .code(429)
        .header('Retry-After', Math.ceil(rateLimitResult.resetMs / 1000).toString())
        .send({
          error: 'Too Many Requests',
          retryAfter: rateLimitResult.resetMs
        });
    }

    // Check for duplicate notification
    if (messageNumber && isNotificationDuplicate(messageNumber, channelId)) {
      server.log.debug({ channelId, messageNumber }, 'Duplicate notification ignored');
      return reply.code(200).send({ status: 'duplicate' });
    }

    // Handle sync message (initial subscription confirmation)
    if (resourceState === 'sync') {
      server.log.info({ channelId }, 'Drive watch channel synced');
      return reply.code(200).send({ status: 'synced' });
    }

    // Handle add notifications (file created or shared)
    if (resourceState === 'add') {
      // Mark notification as processed
      if (messageNumber) {
        markNotificationProcessed(messageNumber, channelId);
      }

      // Queue scan for the watched folder
      server.log.info({ channelId }, 'File added, queueing scan');
      triggerScan(channel.folderId);

      return reply.code(200).send({ status: 'queued' });
    }

    // Handle update notifications
    if (resourceState === 'update') {
      // Process if children changed (files added/removed) or content changed (file modified)
      // Ignore other updates like property/permission changes
      const shouldProcess = changed?.includes('children') || changed?.includes('content');

      if (shouldProcess) {
        // Mark notification as processed
        if (messageNumber) {
          markNotificationProcessed(messageNumber, channelId);
        }

        // Queue scan for the watched folder
        server.log.info({ channelId, changed }, 'Update detected, queueing scan');
        triggerScan(channel.folderId);

        return reply.code(200).send({ status: 'queued' });
      }

      // Acknowledge other update types without processing
      server.log.debug({ channelId, changed }, 'Non-actionable update ignored');
      return reply.code(200).send({ status: 'received' });
    }

    // Handle change notifications (changes API - legacy)
    if (resourceState === 'change') {
      // Mark notification as processed
      if (messageNumber) {
        markNotificationProcessed(messageNumber, channelId);
      }

      // Queue scan for the watched folder
      server.log.info({ channelId, changed }, 'Change detected, queueing scan');
      triggerScan(channel.folderId);

      return reply.code(200).send({ status: 'queued' });
    }

    // Handle other states (remove, trash, untrash, etc.)
    // These are acknowledged but don't trigger processing
    server.log.debug({ channelId, resourceState }, 'Non-actionable resource state');
    return reply.code(200).send({ status: 'received' });
  });
}
